<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Gatsby Starter Blog RSS Feed]]></title><description><![CDATA[誰にでも分かりやすいをモットーに、IT技術的な内容を投稿するブログです。]]></description><link>https://sun0range.tech.server-on.net</link><generator>GatsbyJS</generator><lastBuildDate>Mon, 02 Jun 2025 04:12:29 GMT</lastBuildDate><item><title><![CDATA[WindowsからLinuxへのSSH接続]]></title><description><![CDATA[WindowsマシンからLinux(UbuntuServer)への公開鍵を使ったSSH接続 単純なWindowsマシンからLinux(UbuntuServer)へのSSH接続の方法を紹介します。
特別な事はしませんが、よく忘れるので備忘です。 環境 Windows 11 Home…]]></description><link>https://sun0range.tech.server-on.net/connect-ssh/</link><guid isPermaLink="false">https://sun0range.tech.server-on.net/connect-ssh/</guid><pubDate>Sun, 16 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;WindowsマシンからLinux(UbuntuServer)への公開鍵を使ったSSH接続&lt;/h1&gt;
&lt;p&gt;単純なWindowsマシンからLinux(UbuntuServer)へのSSH接続の方法を紹介します。
特別な事はしませんが、よく忘れるので備忘です。&lt;/p&gt;
&lt;h2&gt;環境&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Windows 11 Home&lt;/li&gt;
&lt;li&gt;Ubuntu Server 22.04 LTS
&lt;ul&gt;
&lt;li&gt;本記事での説明では、ユーザ名を &lt;code&gt;ubuntu&lt;/code&gt; 、IPアドレスを &lt;code&gt;192.168.1.100&lt;/code&gt; としています。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Ubuntu ServerでSSHを有効にする&lt;/h2&gt;
&lt;p&gt;Ubuntu ServerがSSH接続を許可するように設定します。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;OpenSSHのインストール&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Ubuntu ServerにSSHサーバーがインストールされているか確認し、なければインストールします。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;sudo apt update
sudo apt install -y openssh-server
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;SSHサービスの起動と有効化&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;SSHサービスを開始し、再起動後も有効にします。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;sudo systemctl enable --now ssh
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;ファイアウォールの設定（必要に応じて）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ufw を使用してSSHを許可します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;sudo ufw allow OpenSSH
sudo ufw enable
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;Ubuntu ServerのIPアドレスを確認
Ubuntu ServerのローカルIPアドレスを確認します。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;ip a | grep &quot;inet &quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;または&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;hostname -I
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例えば 192.168.1.100 というIPが表示されたら、それをWindowsから使用します。&lt;/p&gt;
&lt;h2&gt;WindowsからSSH接続&lt;/h2&gt;
&lt;p&gt;Windowsでは以下の方法でSSH接続できます。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;WindowsのコマンドプロンプトまたはPowerShellを使用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;まずは接続確認のためにパスワード認証でSSH接続できることを確認します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-powershell&quot;&gt;ssh ユーザー名@IPアドレス
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-powershell&quot;&gt;ssh ubuntu@192.168.1.100
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Windowsから公開鍵を使ったSSH接続&lt;/h3&gt;
&lt;p&gt;セキュリティ面でも楽という面でもパスワード無しでSSH接続するほうがよいので、WindowsでSSHキーを作成し、Ubuntu Serverに登録します。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;WindowsでSSHキーを作成&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;PowerShellまたはWindows Terminalで以下を実行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-powershell&quot;&gt;ssh-keygen -t rsa -b 4096
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;デフォルトの保存場所（C:\Users\ユーザー名.ssh\id_rsa）でEnterを押します。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;公開鍵をUbuntuにコピー&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以下のコマンドでUbuntu Serverに公開鍵を登録。ユーザ名・IPアドレスは適宜変更してください。パスワードも聞かれます。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-powershell&quot;&gt;type $HOME\.ssh\id_rsa.pub | ssh ubuntu@192.168.1.100 &quot;mkdir -p ~/.ssh &amp;#x26;&amp;#x26; cat &gt;&gt; ~/.ssh/authorized_keys&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;鍵認証でSSH接続&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;今後は以下でパスワードなし接続が可能：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-powershell&quot;&gt;ssh ubuntu@192.168.1.100
&lt;/code&gt;&lt;/pre&gt;</content:encoded></item><item><title><![CDATA[Ubuntu ServerでWiFiを使えるようにする手順(MacBook Airでの事例)]]></title><description><![CDATA[Ubuntu ServerでWiFiを使えるようにする手順(MacBook Airでの事例) はじめに 自宅用にServerマシンを構築しようと考えました。k8sを入れたり、色々と使い倒したかったので、少々スペックが欲しかったこともあり、伝手で中古のMacBook Air…]]></description><link>https://sun0range.tech.server-on.net/set-up-wifi-on-ubuntu-in-mac/</link><guid isPermaLink="false">https://sun0range.tech.server-on.net/set-up-wifi-on-ubuntu-in-mac/</guid><pubDate>Sun, 09 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Ubuntu ServerでWiFiを使えるようにする手順(MacBook Airでの事例)&lt;/h1&gt;
&lt;h2&gt;はじめに&lt;/h2&gt;
&lt;p&gt;自宅用にServerマシンを構築しようと考えました。k8sを入れたり、色々と使い倒したかったので、少々スペックが欲しかったこともあり、伝手で中古のMacBook Airを安く手に入り、その上にUbuntuをインストールしました。&lt;/p&gt;
&lt;p&gt;Ubuntuをインストールすること自体は簡単ですが、WiFiを使えるようにするのが大変面倒でした。ネット上でも同様の苦労が多数見受けられたので、私も事例を残しておきたいと思います。インターネット接続がない状態での作業は、特にWiFiドライバのインストールにおいて苦労することがあります。本記事では、スマートフォンを使ったUSBテザリングを利用して、Ubuntu上でWiFiを使えるようにする手順を紹介します。&lt;/p&gt;
&lt;h2&gt;環境情報&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;MacBook Air（2017）
&lt;ul&gt;
&lt;li&gt;CPU: Intel Core i5-5350U @ 1.80GHz&lt;/li&gt;
&lt;li&gt;RAM: 8GB&lt;/li&gt;
&lt;li&gt;GPU: Intel HD Graphics 6000&lt;/li&gt;
&lt;li&gt;SSD: 128GB&lt;/li&gt;
&lt;li&gt;WiFi: Broadcom BCM4360&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Ubuntu Server 22.04 LTS
&lt;ul&gt;
&lt;li&gt;上記MacBook Airにインストール済み。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;手順&lt;/h2&gt;
&lt;h3&gt;初期状態の確認&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ip a&lt;/code&gt;コマンドを実行して、WiFiデバイスが認識されていることを確認します。(仮にコマンドを使えない場合は、&lt;code&gt;networkctl&lt;/code&gt;コマンドを使ってもOKです。)&lt;br&gt;
下記のような出力になるのではないかと思います。&lt;br&gt;
&lt;code&gt;ip a&lt;/code&gt;コマンドの場合。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;ip a
1: lo: &amp;#x3C;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.0/8 scope host lo
       valid_lft forever preferred_lft forever
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;networkctl&lt;/code&gt;コマンドの場合。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;networkctl
IDX LINK             TYPE               OPERATIONAL SETUP
  1 lo               loopback           carrier     unmanaged
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ここでのポイントは&lt;code&gt;wl～&lt;/code&gt;始まりのデバイスがないことで、wlはwirelessを表し、つまりWiFiデバイスが認識されていないことです。&lt;br&gt;
通常各種installをしていって解消していくわけですが、そのためのネットワーク接続がなくて困るわけです。&lt;br&gt;
なので、USBテザリングを使ってインターネット接続を確保します。&lt;/p&gt;
&lt;h4&gt;補足&lt;/h4&gt;
&lt;p&gt;WiFi以外のネットワーク接続として、他の候補としては以下があります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有線LAN (→LANコネクタはMacBookにはなく、変換コネクタの類も持っていなかった)&lt;/li&gt;
&lt;li&gt;Bluetooth (→Bluetoothの設定は面倒そうだったので避けた)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;USBテザリングの準備&lt;/h2&gt;
&lt;p&gt;まず以下の物理的接続を行います。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;スマートフォンとMacBookをUSBケーブルで接続し、スマートフォンの設定からUSBテザリングを有効にします。&lt;/li&gt;
&lt;li&gt;MacBookにスマートフォンを接続します。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;その状態で再度&lt;code&gt;ip a&lt;/code&gt;コマンドを実行すると、&lt;code&gt;en～&lt;/code&gt;始まりのデバイスが増えているはずです。enはethernetを表す有線接続のデバイスです。&lt;br&gt;
その増えた&lt;code&gt;en～&lt;/code&gt;始まりのデバイスをメモしておきます。ちなみにこれは接続するたびに変わるので、毎回確認が必要です。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;ip a
1: lo: &amp;#x3C;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.0/8 scope host lo
       valid_lft forever preferred_lft forever
2: enp0s20u1: &amp;#x3C;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether ab:cd:12:34:56:ef brd ff:ff:ff:ff:ff:ff
    inet 192.168.119.142/24 brd 192.168.119.255 scope global dynamic noprefixroute enp0s20u1
       valid_lft 86399sec preferred_lft 86399sec
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;USBテザリングの設定&lt;/h2&gt;
&lt;p&gt;次に、netplanを使って、USBテザリングを使ってインターネット接続を確保します。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;sudo vi /etc/netplan/60-tmp-tethering.yaml&lt;/code&gt;(ファイル名は任意)のコマンドを入力して、ファイルを作成します。テキストエディタはここではviを使っていますが、他のエディタでも構いません。&lt;/li&gt;
&lt;li&gt;以下の通りファイルの中身を編集します。viの場合、&lt;code&gt;i&lt;/code&gt; でまず入力モードにしたあと &lt;code&gt;escキー&lt;/code&gt; → &lt;code&gt;:wq&lt;/code&gt; で保存して終了します。この時、&lt;em&gt;USBテザリングの準備&lt;/em&gt; で確認した&lt;code&gt;en～&lt;/code&gt;始まりのデバイス名を下記例で言うところの&lt;code&gt;enp0s20u1&lt;/code&gt;を置き換えてください。
&lt;pre&gt;&lt;code class=&quot;language-yaml:/etc/netplan/60-tmp-tethering.yaml&quot;&gt; network:
   version: 2
   renderer: networkd
   ethernets:
      enp0s20u1:
         dhcp4: true
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;以下のコマンドを実行して、設定を反映します。
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; sudo netplan try
&lt;/code&gt;&lt;/pre&gt;
ここで設定不備などあればErrorが出ます。特に問題なければ下記のようになるので、&lt;code&gt;Enterキー&lt;/code&gt; を入力して設定を適用します。
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; Do you want to keep these settings?
 
 Press ENTER before the timeout to accept the new configuration

 Chages will revert in 120 seconds
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;これで暫定的なインターネット接続が確保されました。&lt;code&gt;sudo apt update&lt;/code&gt; などでインターネット接続が確認できるか確認してみてください。&lt;/p&gt;
&lt;h3&gt;補足: netplanとは&lt;/h3&gt;
&lt;p&gt;netplanは、Ubuntu 17.10以降で採用されているネットワーク設定ツールです。
&lt;code&gt;/etc/netplan/&lt;/code&gt; にあるYAMLファイルをアルファベット順に読み取ってネットワーク設定を行います。
元々 &lt;code&gt;/etc/netplan/50-cloud-init.yaml&lt;/code&gt; があるはずですが、それは編集せずに新しいファイルを作成します。&lt;/p&gt;
&lt;h2&gt;WiFiドライバのインストール&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;PCI接続されているであろう内蔵ネットワークカードを &lt;code&gt;lspci&lt;/code&gt; コマンドで確認します。grepで&lt;code&gt;Network&lt;/code&gt;を含む行を抽出すると見やすいです。(ネットワークカードによって表記が違う場合もあるのでその場合はgrep無しで確認してください)
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;lspci | grep Network
03:00.0 Network controller: Broadcom Inc. and subsidiaries BCM4360 802.11ac Wireless Network Adapter (rev 03)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;ターミナルを開き、以下のコマンドを入力して必要なパッケージをインストールします。&lt;br&gt;
ただし、これはBroadcomのBCM4360の場合であり、他のネットワークカードの場合は適切なドライバをインストールしてください。
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo apt-get update
sudo apt-get --reinstall install bcmwl-kernel-source
sudo modprobe -r b43 ssb wl brcmfmac brcmsmac bcma
sudo modprobe wl
sudo reboot
&lt;/code&gt;&lt;/pre&gt;
※参考URL: &lt;a href=&quot;https://help.ubuntu.com/community/WifiDocs/Driver/bcm43xx#Installing_STA_drivers&quot;&gt;https://help.ubuntu.com/community/WifiDocs/Driver/bcm43xx#Installing_STA_drivers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;再起動後、再度&lt;code&gt;ip a&lt;/code&gt;コマンドを実行して、&lt;code&gt;wl～&lt;/code&gt;始まりのWiFiデバイスが認識されていることを確認します。
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;ip a
1: lo: &amp;#x3C;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.0/8 scope host lo
       valid_lft forever preferred_lft forever
2: wlp3s0: &amp;#x3C;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether zy:xw:98:76:54:vu brd ff:ff:ff:ff:ff:ff
    inet 192.168.11.10/24 brd 192.168.11.255 scope global dynamic noprefixroute wlp3s0
       valid_lft 167552sec preferred_lft 167552sec
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;再びnetplanを使って、WiFi用の設定を&lt;code&gt;sudo vi /etc/netplan/90-wifi.yaml&lt;/code&gt;(ファイル名は任意)のコマンドで以下の通りファイルの中身を編集します。&lt;br&gt;
この時、上記で確認した&lt;code&gt;wl～&lt;/code&gt;始まりのデバイス名を下記例で言うところの&lt;code&gt;wlp3s0&lt;/code&gt;を置き換えてください。また、&lt;code&gt;{wifi_SSID_name}&lt;/code&gt; と &lt;code&gt;{your_wifi_password}&lt;/code&gt; はそれぞれ、WiFiのSSID名とパスワードに置き換えてください。
&lt;pre&gt;&lt;code class=&quot;language-yaml:/etc/netplan/90-wifi.yaml&quot;&gt; network:
   version: 2
   renderer: networkd
   wifis:
     wlp3s0:
       dhcp4: true
       optional: true
       access-points:
         {wifi_SSID_name}:
           password: &quot;{your_wifi_password}&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;再び以下のコマンドを実行して、設定を反映します。
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; sudo netplan try
&lt;/code&gt;&lt;/pre&gt;
これでWiFiを使えるようになるはずなのですが、私の環境ではうまくいきませんでした。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;NetworkManagerに変更&lt;/h3&gt;
&lt;p&gt;追加対応ですが、networkdからNetworkManagerに変更します。&lt;br&gt;
これらは本来、serverではnetworkdを、desktopではNetworkManagerを使うという想定ですがWiFi利用において私はうまくいかなかったので切り替えてみます。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;以下のコマンドを実行して、NetworkManagerをインストールします。
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo apt install network-manager
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;netplanの設定をnetworkdからNetworkManagerに変更します。先ほどの &lt;code&gt;90-wifi.yaml&lt;/code&gt; のrendererだけを変えます。
&lt;pre&gt;&lt;code class=&quot;language-yaml:/etc/netplan/90-wifi.yaml&quot;&gt; network:
   version: 2
   renderer: NetworkManager
# 以下略
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;USBテザリングを外した上で&lt;code&gt;sudo apt update&lt;/code&gt; などでインターネット接続が確認できるか確認してみてください。&lt;/li&gt;
&lt;li&gt;ネット接続できることが分かったら、テザリング用のnetplan設定は不要なので削除しておいてください。
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo rm /etc/netplan/60-tmp-tethering.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;本記事では、中古のMacBook AirにUbuntu Serverをインストールし、WiFiを使用できるようにする手順を詳しく解説しました。特に、インターネット接続がない状態でのWiFiドライバのインストールに苦労した経験を共有し、スマートフォンを利用したUSBテザリングを活用する方法を示しました。&lt;/p&gt;
&lt;p&gt;この手順が、同様の環境で作業を行う他のユーザーにとって役立つことを願っています。Ubuntuの柔軟性を活かして、快適なサーバーライフを楽しんでください。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[顔認識をするChrome拡張を実装したので、その紹介と技術的解説]]></title><description><![CDATA[はじめに 子どもを幼稚園に通わせていると、各種イベントの写真がアルバムサイトにアップされることがあります。 今どき多くのサイトでは顔写真検索機能があったりすることも多いのですが、無い所もあって、そういう場合のために自作してしまおうと思ったのがこのChrome…]]></description><link>https://sun0range.tech.server-on.net/chrome-extention-family-photo-finder/</link><guid isPermaLink="false">https://sun0range.tech.server-on.net/chrome-extention-family-photo-finder/</guid><pubDate>Wed, 24 Jul 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;はじめに&lt;/h2&gt;
&lt;p&gt;子どもを幼稚園に通わせていると、各種イベントの写真がアルバムサイトにアップされることがあります。&lt;br&gt;
今どき多くのサイトでは顔写真検索機能があったりすることも多いのですが、無い所もあって、そういう場合のために自作してしまおうと思ったのがこのChrome拡張を作成した背景です。&lt;br&gt;
実際のChrome拡張： &lt;a href=&quot;https://chromewebstore.google.com/detail/family-photo-finder/fikdbpibhbgbedmnmlcfckckpohadebi?authuser=0&amp;#x26;hl=ja&quot;&gt;Family Photo Finder&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Chrome拡張の機能概要&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;集合写真やアルバムサイトで家族の姿を見逃さないためのツール。&lt;/li&gt;
&lt;li&gt;家族や友人の顔画像を事前に登録し、任意のWebページで同じ人物が写っている写真を見つけて枠で囲って表示する。&lt;/li&gt;
&lt;li&gt;機械学習による顔認識なので精度は100%ではなく、検知漏れや誤検知があることをご了承ください。
&lt;ul&gt;
&lt;li&gt;残念なことに、子どもの顔は精度が低いことが多いです。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;使用方法&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Chrome拡張をインストールします。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;https://chromewebstore.google.com/detail/family-photo-finder/fikdbpibhbgbedmnmlcfckckpohadebi?authuser=0&amp;#x26;hl=ja&quot;&gt;ここ&lt;/a&gt;から「Chromeに追加」でインストールできます。&lt;br&gt;
2. 探したい人物の顔画像を登録。(初回のみ)
右上にある拡張アイコンをクリックして、ポップアップを開きます。&lt;br&gt;
すると下記のように、表示する「名前」「枠の色」そして「対象人物の顔画像」を登録してください。1人につき3画像登録でき、多く登録するほど検知精度が上がります。&lt;br&gt;
&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 960px; margin-left: initial;&quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 73.33333333333334%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/webp;base64,UklGRnAAAABXRUJQVlA4IGQAAADwAwCdASoUAA8APtFUo0uoJKMhsAgBABoJZwCsACKUZtNFHidhJA1gAP7rao83R2wGDfSgyCpl+9yB8+YzIlz71zTiHAVeU+sZ8Kjb68zHvxi35ECPNKE/aTGF01sR21UUQAAA&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;picture&gt;
          &lt;source
              srcset=&quot;/static/14340cc92a50ee5f4f925f3fbcb400ab/85704/popup.webp 240w,
/static/14340cc92a50ee5f4f925f3fbcb400ab/2d484/popup.webp 480w,
/static/14340cc92a50ee5f4f925f3fbcb400ab/ac99e/popup.webp 960w,
/static/14340cc92a50ee5f4f925f3fbcb400ab/9b43f/popup.webp 1213w&quot;
              sizes=&quot;(max-width: 960px) 100vw, 960px&quot;
              type=&quot;image/webp&quot;
            /&gt;
          &lt;source
            srcset=&quot;/static/14340cc92a50ee5f4f925f3fbcb400ab/85704/popup.webp 240w,
/static/14340cc92a50ee5f4f925f3fbcb400ab/2d484/popup.webp 480w,
/static/14340cc92a50ee5f4f925f3fbcb400ab/ac99e/popup.webp 960w,
/static/14340cc92a50ee5f4f925f3fbcb400ab/9b43f/popup.webp 1213w&quot;
            sizes=&quot;(max-width: 960px) 100vw, 960px&quot;
            type=&quot;image/webp&quot;
          /&gt;
          &lt;img
            class=&quot;gatsby-resp-image-image&quot;
            src=&quot;/static/14340cc92a50ee5f4f925f3fbcb400ab/ac99e/popup.webp&quot;
            alt=&quot;popup&quot;
            title=&quot;&quot;
            loading=&quot;lazy&quot;
            decoding=&quot;async&quot;
            style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
          /&gt;
        &lt;/picture&gt;
    &lt;/span&gt;&lt;br&gt;
ちなみにこの登録情報はGoogleアカウントで同期されるので、複数のPCで同じ情報が共有されます。&lt;br&gt;
3. 任意のWebページを開きます。
画像に登録した人物が写っている場合、自動で枠が表示されます。
例：
&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 960px; margin-left: initial;&quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 62.5%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/webp;base64,UklGRqAAAABXRUJQVlA4IJQAAAAwBACdASoUAA0APtFUo0uoJKMhsAgBABoJQBOkERwWIk5WI+doIxWbegAA/shzKyjpTGgvHlLmHaUXnUwMPbh7zx8gHjksaH13Yy53KxSIhomRPCu25wZbgKYMGX00Ow3fgjnbOB4bEpkQpIPAQJAAU1uJ15m+CmKXL4f+u8WH8mLeViBqmP0VWxo9oFCheG09wAAA&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;picture&gt;
          &lt;source
              srcset=&quot;/static/7619f7e5aefbf444c0541979ca7073fc/85704/sample.webp 240w,
/static/7619f7e5aefbf444c0541979ca7073fc/2d484/sample.webp 480w,
/static/7619f7e5aefbf444c0541979ca7073fc/ac99e/sample.webp 960w,
/static/7619f7e5aefbf444c0541979ca7073fc/90b83/sample.webp 1280w&quot;
              sizes=&quot;(max-width: 960px) 100vw, 960px&quot;
              type=&quot;image/webp&quot;
            /&gt;
          &lt;source
            srcset=&quot;/static/7619f7e5aefbf444c0541979ca7073fc/85704/sample.webp 240w,
/static/7619f7e5aefbf444c0541979ca7073fc/2d484/sample.webp 480w,
/static/7619f7e5aefbf444c0541979ca7073fc/ac99e/sample.webp 960w,
/static/7619f7e5aefbf444c0541979ca7073fc/90b83/sample.webp 1280w&quot;
            sizes=&quot;(max-width: 960px) 100vw, 960px&quot;
            type=&quot;image/webp&quot;
          /&gt;
          &lt;img
            class=&quot;gatsby-resp-image-image&quot;
            src=&quot;/static/7619f7e5aefbf444c0541979ca7073fc/ac99e/sample.webp&quot;
            alt=&quot;sample&quot;
            title=&quot;&quot;
            loading=&quot;lazy&quot;
            decoding=&quot;async&quot;
            style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
          /&gt;
        &lt;/picture&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;技術的な解説&lt;/h2&gt;
&lt;p&gt;Githubリポジトリはこちら。&lt;a href=&quot;https://github.com/nisioka/face-api-on-chrome-extention&quot;&gt;https://github.com/nisioka/face-api-on-chrome-extention&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;前提1: 使用ライブラリ&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;devDependencies&quot;: {
    &quot;@crxjs/vite-plugin&quot;: &quot;2.0.0-beta.23&quot;,
    &quot;@types/chrome&quot;: &quot;^0.0.268&quot;,
    &quot;typescript&quot;: &quot;^5.5.4&quot;,
    &quot;vite&quot;: &quot;^5.3.5&quot;
  },
  &quot;dependencies&quot;: {
    &quot;@extend-chrome/storage&quot;: &quot;^1.5.0&quot;,
    &quot;@vladmandic/face-api&quot;: &quot;^1.7.13&quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;特筆しておくと、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@crxjs/vite-plugin&lt;/code&gt;はChrome拡張のビルドを行うためのViteプラグインです。マニフェストをTypescriptで型を持ちつつかけたり、いい感じにbuildしてくれたりで、Chrome拡張開発には最適でした。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@extend-chrome/storage&lt;/code&gt;はChromeのストレージを使うためのラッパーライブラリで、無くてもそこまで困りませんが、async/awaitが使えて楽に綺麗に書きやすかったです。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@vladmandic/face-api&lt;/code&gt;はface-api.jsのラッパーライブラリで、TypeScriptで書かれているため、型がしっかりしていて使いやすかったです。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;前提2: face-api.jsの紹介&lt;/h3&gt;
&lt;p&gt;本Chrome拡張では、顔認識機能を実装するためにface-api.jsを使用しています。&lt;br&gt;
face-api.jsとは、ブラウザ上で動作する顔認識用のJavaScriptライブラリです。TensorFlow.jsをベースにしており、高度な顔認識機能を簡単に利用できるように設計されています。&lt;br&gt;
以下はface-api.jsの主な特徴と機能についての説明です。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ブラウザ対応&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ブラウザ上で動作するため、クライアントサイドで顔認識を行え、Chrome拡張での利用にも適しています。
サーバーとの通信が不要なため、プライバシー保護にも寄与します。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高精度の顔認識&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ディープラーニング技術を使用しており、高精度な顔認識が可能です。
事前に学習されたモデルを利用することで、すぐに顔認識機能を実装できます。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多機能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;顔検出、特徴点の抽出、顔のランドマークの検出、顔の特徴ベクトルの取得など、様々な顔認識機能を提供しています。
本Chrome拡張では、顔検出と特徴点の抽出、枠の描画機能も使っていたりします。そのため下記3つのモデルをロードしています。
1つ目は顔検出のために必要、2つ目はランドマーク検出に必要でこれは軽量(tiny)版もありましたが精度が悪く感じたので無印版を、3つ目は顔の特徴ベクトルを取得するために必要です。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ssd_mobilenetv1.weights&lt;/li&gt;
&lt;li&gt;face_landmark_68_model.weights&lt;/li&gt;
&lt;li&gt;face_recognition_model.weights&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ちなみにこれらのモデルデータは、&lt;a href=&quot;https://github.com/justadudewhohacks/face-api.js-models/tree/master/uncompressed&quot;&gt;ここ&lt;/a&gt;から取得しました。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://justadudewhohacks.github.io/face-api.js/docs/index.html&quot;&gt;https://justadudewhohacks.github.io/face-api.js/docs/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://itnext.io/face-api-js-javascript-api-for-face-recognition-in-the-browser-with-tensorflow-js-bcc2a6c4cf07&quot;&gt;https://itnext.io/face-api-js-javascript-api-for-face-recognition-in-the-browser-with-tensorflow-js-bcc2a6c4cf07&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;前提3: Chrome拡張マニフェストV3を使用&lt;/h3&gt;
&lt;p&gt;拡張機能プラットフォームの最新バージョンであるマニフェストV3を使用しています。マニフェストV2は段階的に廃止されています。
スクリプトの実行箇所としては、Webページでの動作の&lt;code&gt;content_scripts&lt;/code&gt;と、バックグラウンドで動く&lt;code&gt;service_worker&lt;/code&gt;がありますが、前者のみを使用しています。
後者はマニフェストV3からの物で、これで動かそうとしましたが、face-api.jsが上手く起動されませんでした。
getEnvに失敗した旨のエラーが出ており、&lt;a href=&quot;https://github.com/justadudewhohacks/face-api.js/issues/47&quot;&gt;こちら&lt;/a&gt;のissueの議論を参考にも見ましたが、WebWorker環境での適切な設定がわからず断念しました。&lt;/p&gt;
&lt;h3&gt;処理詳細説明&lt;/h3&gt;
&lt;h4&gt;1. &lt;a href=&quot;https://github.com/nisioka/face-api-on-chrome-extention/blob/master/src/popup.ts&quot;&gt;popup.ts&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;顔画像の登録としてChromeのストレージに保存、設定値の表示を行うためのものです。&lt;br&gt;
popup.htmlは空っぽで、Chromeストレージから現設定値を初期値として取得し、それを元にゴリゴリとDOMを動的に生成しています。&lt;br&gt;
正直汚くレスポンスも遅いのですが、勢いで書いてしまっています。&lt;br&gt;
ここでユーザが顔写真を登録すると、face-api.jsで顔検出ならびに顔特徴ベクトル(face descriptor)を取得し、それをChromeのsyncストレージに保存しています。&lt;br&gt;
画像自体はChromeのlocalストレージに保存しています。syncには容量の関係で保存が難しいですが、同一端末だけでも画像が見れたほうがいいかと思っての仕様です。&lt;/p&gt;
&lt;p&gt;※注： ここで「ストレージ」といっているのは、&lt;a href=&quot;https://developer.chrome.com/docs/extensions/reference/api/storage?hl=ja&quot;&gt;chrome.storage&lt;/a&gt;のことで、一般的なWebブラウザのローカルストレージとかではないです。&lt;/p&gt;
&lt;h4&gt;2. &lt;a href=&quot;https://github.com/nisioka/face-api-on-chrome-extention/blob/master/src/content_script.ts&quot;&gt;content_script.ts&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;各Webページで動作するスクリプトです。&lt;br&gt;
Webページ読み込み時に、当該ページの「imgタグ」と「CSSでbackground-imageを持つもの」を対象に処理を行います。&lt;br&gt;
face-api.jsを使って、顔検出を行いその全てに足して、登録した顔画像と顔特徴ベクトルが近いかどうかを判定し、一致する場合は強調のための枠を描画します。
canvasを用いて描画していて、そのデータURLを、元の画像URLに差し替えることで、表示しています。&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;以上のように、face-api.jsを用いてChrome拡張機能を実装してみました。&lt;br&gt;
Chrome拡張が故に制約が多くて苦労したところも多かったですが、face-api.jsという強力な機械学習ライブラリがブラウザ上で動くことに感動する気持ちが大きかったです。&lt;/p&gt;
&lt;hr&gt;
&lt;div class=&quot;booklink-box&quot; style=&quot;text-align:left;padding-bottom:20px;font-size:small;zoom: 1;overflow: hidden;&quot;&gt;&lt;div class=&quot;booklink-image&quot; style=&quot;float:left;margin:0 15px 10px 0;&quot;&gt;&lt;a href=&quot;&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;&lt;img src=&quot;https://thumbnail.image.rakuten.co.jp/@0_mall/book/cabinet/2644/9784777522644_1_2.jpg?_ex=200x200&quot; style=&quot;border: none;&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;booklink-info&quot; style=&quot;line-height:120%;zoom: 1;overflow: hidden;&quot;&gt;&lt;div class=&quot;booklink-name&quot; style=&quot;margin-bottom:10px;line-height:120%&quot;&gt;&lt;a href=&quot;&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;Chrome拡張×ChatGPTで作業効率化&lt;/a&gt;&lt;div class=&quot;booklink-powered-date&quot; style=&quot;font-size:8pt;margin-top:5px;font-family:verdana;line-height:120%&quot;&gt;posted with &lt;a href=&quot;https://yomereba.com&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;ヨメレバ&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;booklink-detail&quot; style=&quot;margin-bottom:5px;&quot;&gt;I/O編集部 工学社 2023年08月29日頃    &lt;/div&gt;&lt;div class=&quot;booklink-link2&quot; style=&quot;margin-top:10px;&quot;&gt;&lt;div class=&quot;shoplinkamazon&quot; style=&quot;margin:5px 0&quot;&gt;&lt;a href=&quot;//af.moshimo.com/af/c/click?a_id=1041250&amp;amp;p_id=170&amp;amp;pc_id=185&amp;amp;pl_id=4062&amp;amp;s_v=b5Rz2P0601xu&amp;amp;url=https%3A%2F%2Fwww.amazon.co.jp%2Fexec%2Fobidos%2FASIN%2F4777522644&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;Amazon&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;shoplinkkindle&quot; style=&quot;margin:5px 0&quot;&gt;&lt;a href=&quot;//af.moshimo.com/af/c/click?a_id=1041250&amp;amp;p_id=170&amp;amp;pc_id=185&amp;amp;pl_id=4062&amp;amp;s_v=b5Rz2P0601xu&amp;amp;url=https%3A%2F%2Fwww.amazon.co.jp%2Fgp%2Fsearch%3Fkeywords%3DChrome%25E6%258B%25A1%25E5%25BC%25B5%25C3%2597ChatGPT%25E3%2581%25A7%25E4%25BD%259C%25E6%25A5%25AD%25E5%258A%25B9%25E7%258E%2587%25E5%258C%2596%26__mk_ja_JP%3D%2583J%2583%255E%2583J%2583i%26url%3Dnode%253D2275256051&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;Kindle&lt;/a&gt;&lt;/div&gt;                               	   	   	  	  &lt;div class=&quot;shoplinktoshokan&quot; style=&quot;margin:5px 0&quot;&gt;&lt;a href=&quot;http://calil.jp/book/4777522644&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;図書館&lt;/a&gt;&lt;/div&gt;	&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;booklink-footer&quot; style=&quot;clear: left&quot;&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[静的サイトでの動的なサイト内検索機能の実装を紹介]]></title><description><![CDATA[はじめに 本ブログは GatsbyJS…]]></description><link>https://sun0range.tech.server-on.net/introduce-search-page/</link><guid isPermaLink="false">https://sun0range.tech.server-on.net/introduce-search-page/</guid><pubDate>Wed, 26 Jun 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;はじめに&lt;/h2&gt;
&lt;p&gt;本ブログは GatsbyJS を使用して静的サイトとして運用しています。&lt;/p&gt;
&lt;p&gt;ただ、それでもサイト内検索などの動的な機能が必要であると考え、実装しました。
非常に軽快で満足できる実装になりました。ぜひこちらの&lt;a href=&quot;/search&quot; target=&quot;_brank&quot;&gt;検索ページ&lt;/a&gt;をご覧いただき、お試しください。&lt;/p&gt;
&lt;p&gt;実際のコードが見たい場合は、&lt;a href=&quot;https://github.com/nisioka/sun0range.com/blob/master/src/pages/search.tsx&quot; target=&quot;_blank&quot;&gt;こちら&lt;/a&gt;をご覧ください。&lt;/p&gt;
&lt;h2&gt;全体仕様&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;このページは、検索機能を提供します。API コールを行わず、ブラウザの JavaScript で動作します。
&lt;ul&gt;
&lt;li&gt;モバイル環境でも軽快に動作しますが、検索対象の増加によって性能が低下する可能性があります。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;検索文字列の入力 1 文字ごとにインタラクティブに検索結果を表示します。&lt;/li&gt;
&lt;li&gt;URL のクエリパラメータに検索文字列が含まれ、入力フォームと同期しているため、リロードしても同じ表示が行われ、検索結果の URL で共有もできます。&lt;/li&gt;
&lt;li&gt;検索対象は全ての記事であり、タイトルか記事内容に文字列が含まれるかどうかで判定します。複数ワード検索はスペースで区切って行えます。大文字と小文字は区別しません。&lt;/li&gt;
&lt;li&gt;検索結果には、ヒット件数と記事のタイトルと説明文が表示されます。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;詳細説明&lt;/h2&gt;
&lt;p&gt;必要最小限のコードを抜粋しています。これに基づいて後述します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;import React, { useEffect, useState } from &quot;react&quot;
import { graphql, Link } from &quot;gatsby&quot;
import { convertCategory, mergePosts } from &quot;../utilFunction&quot;

const Search = ({ data, location }: { data: any; location: Location }) =&gt; {
  const posts = mergePosts(data.allMarkdownRemark, data.allWpPost, data.allFile)
  const initQuery = decodeURI(
    location.href?.split(&quot;?q=&quot;)[1] || &quot;&quot;
  ).toLowerCase()
  const [state, setState] = useState({
    filteredData: filterByQuery(initQuery.split(/\s+/)),
    query: initQuery,
  })
  const { filteredData, query } = state

  function filterByQuery(queryWords: string[]) {
    return posts.filter(post =&gt; {
      for (const word of queryWords) {
        if (
          !post.title.toLowerCase().includes(word) &amp;#x26;&amp;#x26;
          !post.description?.toLowerCase().includes(word)
        ) {
          return false
        }
      }
      return true
    })
  }
  function handleInputChange(event: React.ChangeEvent&amp;#x3C;HTMLInputElement&gt;) {
    const queryWords = event.target.value.toLowerCase().split(/\s+/)

    setState(prevState =&gt; ({
      ...prevState,
      filteredData: filterByQuery(queryWords),
      query: queryWords.join(&quot; &quot;),
    }))
  }

  useEffect(() =&gt; {
    // ユーザーの入力があるたびにURLのクエリパラメータを更新
    const params = new URLSearchParams()
    if (query) {
      params.append(&quot;q&quot;, query)
    } else {
      params.delete(&quot;q&quot;)
    }
    window.history.replaceState(
      &quot;&quot;,
      &quot;&quot;,
      location.href.split(&quot;?&quot;)[0] +
        (params.size &gt; 0 ? &quot;?&quot; + params.toString() : &quot;&quot;)
    )
  }, [state.query])

  return (
    &amp;#x3C;&gt;
      &amp;#x3C;input
        type=&quot;text&quot;
        aria-label=&quot;Search&quot;
        placeholder=&quot;検索ワードを入力...&quot;
        onChange={handleInputChange}
        value={query}
      /&gt;
      &amp;#x3C;div className=&quot;result-inner__res&quot;&gt;
        {query !== &quot;&quot;
          ? query + &quot; の検索結果: &quot; + filteredData.length + &quot;件&quot;
          : filteredData.length + &quot;件の記事があります&quot;}
      &amp;#x3C;/div&gt;
      &amp;#x3C;h1&gt;サイト内検索&amp;#x3C;/h1&gt;
      &amp;#x3C;p&gt;{filteredData.length} 記事あります&amp;#x3C;/p&gt;
      {filteredData.map(post =&gt; {
        return (
          &amp;#x3C;li key={post.slug}&gt;
            &amp;#x3C;Link to={`/${convertCategory(post.category)}/${post.slug}`}&gt;
              &amp;#x3C;h2&gt;
                &amp;#x3C;span&gt;{post.title}&amp;#x3C;/span&gt;
              &amp;#x3C;/h2&gt;
              &amp;#x3C;section&gt;
                &amp;#x3C;p dangerouslySetInnerHTML={{ __html: post.excerpt }} /&gt;
              &amp;#x3C;/section&gt;
            &amp;#x3C;/Link&gt;
          &amp;#x3C;/li&gt;
        )
      })}
    &amp;#x3C;/&gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;検索対象となる全記事データを取得します。これはほぼ GatsbyJS の機能を利用しています。&quot;mergePosts&quot;関数は単に&lt;code&gt;pageQuery&lt;/code&gt;で取得した data を使いやすい形に整形しているだけです。&lt;/li&gt;
&lt;li&gt;&quot;useState&quot;フックを使用して、フィルタリングされたデータとクエリを保持する&quot;state&quot;と&quot;setState&quot;を定義します。初期値として、URL のクエリパラメータに基づいて設定します。&lt;/li&gt;
&lt;li&gt;&quot;filterByQuery&quot;関数を定義しています。この関数は、クエリワードに基づいて記事をフィルタリングします。各記事のタイトルと説明をクエリワードと比較し、一致する記事のみを返します。&lt;/li&gt;
&lt;li&gt;&quot;handleInputChange&quot;関数も定義しています。ユーザーの入力に応じてクエリを更新し、フィルタリングされたデータを更新します。&lt;/li&gt;
&lt;li&gt;&quot;useEffect&quot;フックは、コンポーネントのレンダリング後に実行されます。ユーザーが入力したクエリで URL のクエリパラメータを更新します。つまり、同期させます。&lt;/li&gt;
&lt;li&gt;最後に、レイアウトと検索結果を表示する JSX が返されます。入力欄、検索結果の表示、およびフィルタリングされた記事のリストが表示されます。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;おわりに&lt;/h2&gt;
&lt;p&gt;以上です。少ない記述でやりたいことができるので、ぜひ参考にしてみてください。&lt;br&gt;
React の強力さを感じました。&lt;/p&gt;
&lt;hr&gt;
&lt;div class=&quot;booklink-box&quot; style=&quot;text-align:left;padding-bottom:20px;font-size:small;zoom: 1;overflow: hidden;&quot;&gt;&lt;div class=&quot;booklink-image&quot; style=&quot;float:left;margin:0 15px 10px 0;&quot;&gt;&lt;a href=&quot;&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;&lt;img src=&quot;https://thumbnail.image.rakuten.co.jp/@0_mall/book/cabinet/9546/9784844379546.jpg?_ex=200x200&quot; style=&quot;border: none;&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;booklink-info&quot; style=&quot;line-height:120%;zoom: 1;overflow: hidden;&quot;&gt;&lt;div class=&quot;booklink-name&quot; style=&quot;margin-bottom:10px;line-height:120%&quot;&gt;&lt;a href=&quot;&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;【POD】React &amp;amp; Gatsby開発入門&lt;/a&gt;&lt;div class=&quot;booklink-powered-date&quot; style=&quot;font-size:8pt;margin-top:5px;font-family:verdana;line-height:120%&quot;&gt;posted with &lt;a href=&quot;https://yomereba.com&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;ヨメレバ&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;booklink-detail&quot; style=&quot;margin-bottom:5px;&quot;&gt;竹本 雄貴 インプレスR&amp;amp;D 2021年04月02日頃    &lt;/div&gt;&lt;div class=&quot;booklink-link2&quot; style=&quot;margin-top:10px;&quot;&gt;&lt;div class=&quot;shoplinkamazon&quot; style=&quot;margin:5px 0&quot;&gt;&lt;a href=&quot;//af.moshimo.com/af/c/click?a_id=1041250&amp;amp;p_id=170&amp;amp;pc_id=185&amp;amp;pl_id=4062&amp;amp;s_v=b5Rz2P0601xu&amp;amp;url=https%3A%2F%2Fwww.amazon.co.jp%2Fexec%2Fobidos%2FASIN%2F4844379542&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;Amazon&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;shoplinkkindle&quot; style=&quot;margin:5px 0&quot;&gt;&lt;a href=&quot;//af.moshimo.com/af/c/click?a_id=1041250&amp;amp;p_id=170&amp;amp;pc_id=185&amp;amp;pl_id=4062&amp;amp;s_v=b5Rz2P0601xu&amp;amp;url=https%3A%2F%2Fwww.amazon.co.jp%2Fgp%2Fsearch%3Fkeywords%3D%25E3%2580%2590POD%25E3%2580%2591React%2520%2526%2520Gatsby%25E9%2596%258B%25E7%2599%25BA%25E5%2585%25A5%25E9%2596%2580%26__mk_ja_JP%3D%2583J%2583%255E%2583J%2583i%26url%3Dnode%253D2275256051&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;Kindle&lt;/a&gt;&lt;/div&gt;                               	   	   	  	  &lt;div class=&quot;shoplinktoshokan&quot; style=&quot;margin:5px 0&quot;&gt;&lt;a href=&quot;http://calil.jp/book/4844379542&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;図書館&lt;/a&gt;&lt;/div&gt;	&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;booklink-footer&quot; style=&quot;clear: left&quot;&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[MarkdownでもWordPressでも使えるGatsbyJSでの構文ハイライト]]></title><description><![CDATA[概要 GatsbyJS での汎用的な構文ハイライト(syntax highlight)の実装方法を紹介します。 本ブログは Markdown ファイルと WordPress の両方のコンテンツを Gatsby…]]></description><link>https://sun0range.tech.server-on.net/syntax-highlight-on-gatsbyjs/</link><guid isPermaLink="false">https://sun0range.tech.server-on.net/syntax-highlight-on-gatsbyjs/</guid><pubDate>Mon, 10 Jun 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;概要&lt;/h2&gt;
&lt;p&gt;GatsbyJS での汎用的な構文ハイライト(syntax highlight)の実装方法を紹介します。&lt;br&gt;
本ブログは Markdown ファイルと WordPress の両方のコンテンツを Gatsby で表示していて、その場合に使えるやり方です。もちろんどちらかのみの場合でも OK です。&lt;br&gt;
&lt;code&gt;react-syntax-highlighter&lt;/code&gt;というプラグインを使って、それに上手くコンテンツデータを渡すということをやってます。&lt;/p&gt;
&lt;p&gt;参考にしたサイトはこちら。&lt;br&gt;
&lt;a href=&quot;https://dimitri.codes/adding-syntax-highlighting-wordpress-gatsby/&quot; target=&quot;_blank&quot;&gt;&lt;a href=&quot;https://dimitri.codes/adding-syntax-highlighting-wordpress-gatsby/&quot;&gt;https://dimitri.codes/adding-syntax-highlighting-wordpress-gatsby/&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;また、実コードが見たい方は、実際の変更コミットはこちらを見てください。&lt;br&gt;
&lt;a href=&quot;https://github.com/nisioka/sun0range.com/commit/7a469363fc9b309f720cf7903ba1da5ce39f9895&quot; target=&quot;_blank&quot;&gt;&lt;a href=&quot;https://github.com/nisioka/sun0range.com/commit/7a469363fc9b309f720cf7903ba1da5ce39f9895&quot;&gt;https://github.com/nisioka/sun0range.com/commit/7a469363fc9b309f720cf7903ba1da5ce39f9895&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;前提・準備&lt;/h2&gt;
&lt;p&gt;Gatsby でのコンテンツを表示に、&lt;code&gt;dangerouslySetInnerHtml={{__html=content}}&lt;/code&gt; を使用していることを想定していて、それを書き換えていきます。
また、TypeScript も使用しているので以降のコードも.ts もしくは.tsx です。&lt;/p&gt;
&lt;p&gt;まずは依存関係のインストールを行ってください。(TypeScript なので、開発のしやすさのために@types も dev に入れてます。)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;npm install --save html-react-parser react-syntax-highlighter
npm install --save-dev @types/react-syntax-highlighter
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;実装&lt;/h2&gt;
&lt;p&gt;まず、修正前の実装イメージを示します。&lt;strong&gt;post.content&lt;/strong&gt;がコンテンツデータで、それを dangerouslySetInnerHTML に渡して表示しているとします。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;import * as React from &quot;react&quot;

const BlogPostTemplate = () =&gt; {
  // ノイズになるため省略。ここでpostのデータを取得したりしている。

  return (
    &amp;#x3C;&gt;
      // ノイズになるため省略。実際は他にもレイアウトしている。
      &amp;#x3C;section dangerouslySetInnerHTML={{ __html: post.content }} /&gt;
    &amp;#x3C;/&gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修正後のコードが下記です。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;import * as React from &quot;react&quot;
import { Link, graphql } from &quot;gatsby&quot;

import parse, { domToReact } from &quot;html-react-parser&quot;
import SyntaxHighlighter from &quot;react-syntax-highlighter&quot;
import { androidstudio } from &quot;react-syntax-highlighter/dist/cjs/styles/hljs&quot;

const BlogPostTemplate = () =&gt; {
  // ノイズになるため省略。ここでpostのデータを取得したりしている。

  return (
    &amp;#x3C;&gt;
      // ノイズになるため省略。実際は他にもレイアウトしている。
      &amp;#x3C;section&gt;{parse(post.content, { replace: replaceCode })}&amp;#x3C;/section&gt;
    &amp;#x3C;/&gt;
  )
}

const replaceCode = (node: any) =&gt; {
  if (!node) return node
  if (node.name === &quot;pre&quot;) {
    const dom = domToReact(getCode(node))
    let result = &quot;&quot;
    switch (typeof dom) {
      case &quot;string&quot;:
        result = dom as string
        break
      case &quot;object&quot;:
        if (Array.isArray(dom)) {
          // React.JSX.Element[]
          const elmArr = dom as React.JSX.Element[]
          elmArr.map(elm =&gt; {
            if (elm.props &amp;#x26;&amp;#x26; elm.props.children) {
              result += elm.props.children as string
            }
          })
        } else {
          // React.JSX.Element
          const elm = dom as React.JSX.Element
          if (elm.props &amp;#x26;&amp;#x26; elm.props.children) {
            result = elm.props.children as string
          }
        }
        break
    }

    return (
      node.children.length &gt; 0 &amp;#x26;&amp;#x26; (
        &amp;#x3C;SyntaxHighlighter
          style={androidstudio}
          language={getLanguage(node)}
          showLineNumbers={true}
        &gt;
          {result}
        &amp;#x3C;/SyntaxHighlighter&gt;
      )
    )
  }
}

const getLanguage = (node: any) =&gt; {
  function getClassInLanguage(className: string) {
    let result = &quot;&quot;
    className.split(/\s+/).forEach(s =&gt; {
      if (s.startsWith(&quot;language-&quot;)) {
        result = s.replace(&quot;language-&quot;, &quot;&quot;)
        break
      }
    })
    return result
  }

  if (node.attribs.class &amp;#x26;&amp;#x26; node.attribs.class !== &quot;wp-block-code&quot;) {
    return getClassInLanguage(node.attribs.class as string)
  } else if (node.children[0]?.attribs?.class) {
    return getClassInLanguage(node.children[0].attribs.class as string)
  }
  return &quot;java&quot; // default
}

const getCode = (node: any) =&gt; {
  if (node.children.length &gt; 0 &amp;#x26;&amp;#x26; node.children[0].name === &quot;code&quot;) {
    return node.children[0].children
  } else {
    return node.children
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上記コードについて説明します。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;元々&lt;code&gt;dangerouslySetInnerHTML&lt;/code&gt;を使っていたものを、&lt;code&gt;html-react-parser&lt;/code&gt;ライブラリの&lt;code&gt;parse&lt;/code&gt;関数を使うように変更します。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;parse&lt;/code&gt;関数は HTML を React コンポーネントに変換し、後述する自作の&lt;code&gt;replaceCode&lt;/code&gt;関数を使用して&lt;code&gt;&amp;#x3C;code&gt;&lt;/code&gt;ブロックを検出します。それ以外はそのままです。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;replaceCode&lt;/code&gt;関数はコードブロックをハイライト表示するための処理を行います。
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;parse&lt;/code&gt;関数が DOM 要素を node として一つづつ渡してくるので、node が「&lt;code&gt;&amp;#x3C;pre&gt;&lt;/code&gt;タグ内に&lt;code&gt;&amp;#x3C;code&gt;&lt;/code&gt;の子を持つ要素」&lt;strong&gt;以外&lt;/strong&gt;の要素の場合は、置き換えせずそのままです。&lt;/li&gt;
&lt;li&gt;「&lt;code&gt;&amp;#x3C;pre&gt;&lt;/code&gt;タグ内に&lt;code&gt;&amp;#x3C;code&gt;&lt;/code&gt;の子を持つ要素」である場合、その中のコードを取得し、&lt;code&gt;react-syntax-highlighter&lt;/code&gt;ライブラリの&lt;code&gt;SyntaxHighlighter&lt;/code&gt;コンポーネントで整形します。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SyntaxHighlighter&lt;/code&gt;コンポーネントでは、言語やスタイルが選べて、
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;language&lt;/code&gt;には&lt;a href=&quot;https://github.com/react-syntax-highlighter/react-syntax-highlighter/blob/HEAD/AVAILABLE_LANGUAGES_HLJS.MD&quot; target=&quot;_blank&quot;&gt;ここ&lt;/a&gt;にある言語を指定します。その言語の指定の仕方はメタ情報として付与されている html の class 名を使って自作の&lt;code&gt;getLanguage&lt;/code&gt;関数で判定しています。
&lt;ol&gt;
&lt;li&gt;Markdown では、&lt;code&gt; ```javascript&lt;/code&gt;というようにコードブロックの先頭に指定します。&lt;/li&gt;
&lt;li&gt;WordPress では，「高度な設定」の「追加 CSS クラス」に&lt;code&gt;language-XXX&lt;/code&gt;というように XXX に言語を指定します。(※1)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;style&lt;/code&gt;には&lt;a href=&quot;https://github.com/react-syntax-highlighter/react-syntax-highlighter/blob/HEAD/AVAILABLE_STYLES_HLJS.MD&quot; target=&quot;_blank&quot;&gt;ここ&lt;/a&gt;にある好きなスタイルを指定します。色々と試して好きな見た目を選んでください。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;※1: WordPress の「高度な設定」の例。
&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 428px; margin-left: initial;&quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 126.25%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/webp;base64,UklGRmwAAABXRUJQVlA4IGAAAADwAwCdASoUABkAPtFgqU+oJaOiKAgBABoJaWZAABtpPv5NaNbZIPAAAP7xPjXQ5H1FJFMEGpXXawNXdJQ9UT+vOuw37DYX463ZeYb0Vpc0pOnes6x+/OUyEoRya9IAAAA=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;picture&gt;
          &lt;source
              srcset=&quot;/static/e5f0aa6338a6db2c83efeef2006a64ee/85704/wordpressExample.webp 240w,
/static/e5f0aa6338a6db2c83efeef2006a64ee/f403b/wordpressExample.webp 428w&quot;
              sizes=&quot;(max-width: 428px) 100vw, 428px&quot;
              type=&quot;image/webp&quot;
            /&gt;
          &lt;source
            srcset=&quot;/static/e5f0aa6338a6db2c83efeef2006a64ee/85704/wordpressExample.webp 240w,
/static/e5f0aa6338a6db2c83efeef2006a64ee/f403b/wordpressExample.webp 428w&quot;
            sizes=&quot;(max-width: 428px) 100vw, 428px&quot;
            type=&quot;image/webp&quot;
          /&gt;
          &lt;img
            class=&quot;gatsby-resp-image-image&quot;
            src=&quot;/static/e5f0aa6338a6db2c83efeef2006a64ee/f403b/wordpressExample.webp&quot;
            alt=&quot;wordpressExample&quot;
            title=&quot;&quot;
            loading=&quot;lazy&quot;
            decoding=&quot;async&quot;
            style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
          /&gt;
        &lt;/picture&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;終わりに&lt;/h2&gt;
&lt;p&gt;以上で、Gatsby アプリケーションを実行し、構文ハイライトされたコードを確認できるはずです。本記事内のコードも構文ハイライトされて見えているはずです。
これで、WordPress と Gatsby で構文ハイライトを実装しました。完全な例に興味がある場合は、このブログのソースコードを 以下の GitHub で確認できます。
&lt;a href=&quot;https://github.com/nisioka/sun0range.com/blob/master/src/templates/blog-post.tsx&quot;&gt;https://github.com/nisioka/sun0range.com/blob/master/src/templates/blog-post.tsx&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;div class=&quot;booklink-box&quot; style=&quot;text-align:left;padding-bottom:20px;font-size:small;zoom: 1;overflow: hidden;&quot;&gt;&lt;div class=&quot;booklink-image&quot; style=&quot;float:left;margin:0 15px 10px 0;&quot;&gt;&lt;a href=&quot;&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;&lt;img src=&quot;https://thumbnail.image.rakuten.co.jp/@0_mall/book/cabinet/9546/9784844379546.jpg?_ex=200x200&quot; style=&quot;border: none;&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;booklink-info&quot; style=&quot;line-height:120%;zoom: 1;overflow: hidden;&quot;&gt;&lt;div class=&quot;booklink-name&quot; style=&quot;margin-bottom:10px;line-height:120%&quot;&gt;&lt;a href=&quot;&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;【POD】React &amp;amp; Gatsby開発入門&lt;/a&gt;&lt;div class=&quot;booklink-powered-date&quot; style=&quot;font-size:8pt;margin-top:5px;font-family:verdana;line-height:120%&quot;&gt;posted with &lt;a href=&quot;https://yomereba.com&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;ヨメレバ&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;booklink-detail&quot; style=&quot;margin-bottom:5px;&quot;&gt;竹本 雄貴 インプレスR&amp;amp;D 2021年04月02日頃    &lt;/div&gt;&lt;div class=&quot;booklink-link2&quot; style=&quot;margin-top:10px;&quot;&gt;&lt;div class=&quot;shoplinkamazon&quot; style=&quot;margin:5px 0&quot;&gt;&lt;a href=&quot;//af.moshimo.com/af/c/click?a_id=1041250&amp;amp;p_id=170&amp;amp;pc_id=185&amp;amp;pl_id=4062&amp;amp;s_v=b5Rz2P0601xu&amp;amp;url=https%3A%2F%2Fwww.amazon.co.jp%2Fexec%2Fobidos%2FASIN%2F4844379542&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;Amazon&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;shoplinkkindle&quot; style=&quot;margin:5px 0&quot;&gt;&lt;a href=&quot;//af.moshimo.com/af/c/click?a_id=1041250&amp;amp;p_id=170&amp;amp;pc_id=185&amp;amp;pl_id=4062&amp;amp;s_v=b5Rz2P0601xu&amp;amp;url=https%3A%2F%2Fwww.amazon.co.jp%2Fgp%2Fsearch%3Fkeywords%3D%25E3%2580%2590POD%25E3%2580%2591React%2520%2526%2520Gatsby%25E9%2596%258B%25E7%2599%25BA%25E5%2585%25A5%25E9%2596%2580%26__mk_ja_JP%3D%2583J%2583%255E%2583J%2583i%26url%3Dnode%253D2275256051&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;Kindle&lt;/a&gt;&lt;/div&gt;                               	   	   	  	  &lt;div class=&quot;shoplinktoshokan&quot; style=&quot;margin:5px 0&quot;&gt;&lt;a href=&quot;http://calil.jp/book/4844379542&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;図書館&lt;/a&gt;&lt;/div&gt;	&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;booklink-footer&quot; style=&quot;clear: left&quot;&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[AWSにデプロイしていたWordPressサイトをGatsbyJSによるGitHub Pagesでの静的サイトへ移行]]></title><description><![CDATA[はじめに 本ブログは WordPress を AWS にデプロイして運用していましたが、GatsbyJS を使って GitHub Pages…]]></description><link>https://sun0range.tech.server-on.net/migrate-from-wordpress/</link><guid isPermaLink="false">https://sun0range.tech.server-on.net/migrate-from-wordpress/</guid><pubDate>Sun, 09 Jun 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;はじめに&lt;/h2&gt;
&lt;p&gt;本ブログは WordPress を AWS にデプロイして運用していましたが、GatsbyJS を使って GitHub Pages での静的サイトへの移行を行いました。その手順をここに残します。&lt;br&gt;
ちなみに、移行のモチベーションとしては、下記がありました。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;金銭的コストの削減をしたい&lt;/li&gt;
&lt;li&gt;サイトのパフォーマンス向上を図りたい&lt;/li&gt;
&lt;li&gt;セキュリティリスクを無くし、運用コストも下げたい&lt;/li&gt;
&lt;li&gt;AWS の使用経験を活かしつつ、新しい技術スタックへの挑戦も兼ねて(今回は React の実践として良かった)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Before の運用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;WordPress を AWS の EC2 で動かす。
&lt;ul&gt;
&lt;li&gt;記事は Web 上の WordPress 管理者画面から投稿する。
&lt;ul&gt;
&lt;li&gt;（これにより、管理者の乗っ取りやデータベース等への不正アクセスなどのセキュリティリスクが存在していました。）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CloudFront でキャッシュを効かせて、サイトパフォーマンスの向上を図ってはいた。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;After の運用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;既存の WordPress のバックアップをローカル PC で動かす。&lt;/li&gt;
&lt;li&gt;新規の記事は Markdown ファイルで記述する。&lt;/li&gt;
&lt;li&gt;上記をソースにして、GatsbyJS で SSG(Static Site Generation)でビルドする。
&lt;ul&gt;
&lt;li&gt;静的ファイルを GitHub Pages でホスティングする。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;移行手順概要&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;WordPress サイトデータのエクスポート&lt;/li&gt;
&lt;li&gt;WordPress のローカル環境へのインポート&lt;/li&gt;
&lt;li&gt;GatsbyJS のセットアップ&lt;/li&gt;
&lt;li&gt;サイトのビルドとデプロイ&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;1. WordPress サイトデータのエクスポート&lt;/h3&gt;
&lt;p&gt;まず、WordPress サイトからデータをエクスポートします。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;WordPress 管理ダッシュボード&lt;/strong&gt;にログインします。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ツール&lt;/strong&gt; &gt; &lt;strong&gt;エクスポート&lt;/strong&gt;を選択します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;すべてのコンテンツ&lt;/strong&gt;を選び、&lt;strong&gt;エクスポートファイルをダウンロード&lt;/strong&gt;をクリックします。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;これで、投稿、ページ、メディアなどのデータを含む XML ファイルがダウンロードされます。&lt;/p&gt;
&lt;h3&gt;2. WordPress データのインポート&lt;/h3&gt;
&lt;p&gt;次に、ローカル環境で WordPress をセットアップし、エクスポートしたデータをインポートします。&lt;/p&gt;
&lt;p&gt;この&lt;a href=&quot;https://github.com/nisioka/docker-wordpress/blob/develop/docker-compose.yml&quot;&gt;docker-compose.yml&lt;/a&gt;を使って、WordPress をローカル環境でセットアップします。&lt;br&gt;
これには、WordPress 本体とその DB、phpMyAdmin が含まれているので、起動させて &lt;a href=&quot;http://localhost&quot;&gt;http://localhost&lt;/a&gt; にアクセスすると空の WordPress が表示されます。&lt;br&gt;
適当に初期設定を行った後、WordPress の管理画面にログインし、エクスポートしたデータをインポートします。&lt;/p&gt;
&lt;p&gt;そして、WordPress のプラグインについても整理します。&lt;br&gt;
不要なプラグインは削除しましょう。特に、ローカル環境では正常に動作しないことがある認証系のプラグインは削除することをお勧めします。公開するわけでは無いローカル環境なのでセキュリティを高める必要がありません。
また、GatsbyJS で WordPress のデータを取得するための以下のプラグインを追加インストールします。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WP Gatsby&lt;/li&gt;
&lt;li&gt;WPGraphQL&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;この状態で既存の WordPress 記事がローカルでも表示できていれば、次に進みます。&lt;/p&gt;
&lt;h3&gt;3. GatsbyJS のセットアップ&lt;/h3&gt;
&lt;p&gt;次に、GatsbyJS をセットアップします。&lt;/p&gt;
&lt;p&gt;前提： &lt;code&gt;Node.js&lt;/code&gt;と&lt;code&gt;npm&lt;/code&gt;がインストールされていること。&lt;/p&gt;
&lt;p&gt;Gatsby CLI をインストールし、新しい Gatsby プロジェクトを作成します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;npm install -g gatsby-cli
gatsby new my-gatsby-blog
cd my-gatsby-blog
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;※ ここでの my-gatsby-blog はプロジェクト名として例示していますので、任意の名前に置き換えてください。&lt;/p&gt;
&lt;p&gt;GatsbyJS で WordPress のデータを取得するためのプラグインをインストールします。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;npm install gatsby-source-wordpress
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;gatsby-config.js ファイルを編集して、WordPress サイトのデータを取得するように設定します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;module.exports = {
  plugins: [
    {
      resolve: `gatsby-source-wordpress`,
      options: {
        url: `http://localhost/graphql`,
      },
    },
  ],
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;gatsby-node.js ファイルを作成し、WordPress の投稿を Gatsby のページとして生成するスクリプトを追加します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const path = require(`path`)

exports.createPages = async ({ graphql, actions }) =&gt; {
  const { createPage } = actions

  const result = await graphql(`
    {
      allWpPost {
        nodes {
          slug
        }
      }
    }
  `)

  result.data.allWpPost.nodes.forEach(node =&gt; {
    createPage({
      path: node.slug,
      component: path.resolve(`./src/templates/blog-post.js`),
      context: {
        slug: node.slug,
      },
    })
  })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;4. サイトのビルドとデプロイ&lt;/h2&gt;
&lt;p&gt;最後に、サイトをビルドし、GitHub Pages にデプロイします。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;gatsby build
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;リポジトリを作成し、GitHub Pages にデプロイします。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git init
git remote add origin https://github.com/your-username/your-repo.git
git add .
git commit -m &quot;Initial commit&quot;
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;GitHub Pages の設定で、デプロイするブランチを gh-pages に設定します。&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 960px; margin-left: initial;&quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 49.16666666666667%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/webp;base64,UklGRj4AAABXRUJQVlA4IDIAAAAQAwCdASoUAAoAPtFUo0uoJKMhsAgBABoJaQAAetG6tAAA/vHOiC2If0a5ITapUAAAAA==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;picture&gt;
          &lt;source
              srcset=&quot;/static/4678034b69a1447288d53841ea6c4435/85704/githubPagesSetting.webp 240w,
/static/4678034b69a1447288d53841ea6c4435/2d484/githubPagesSetting.webp 480w,
/static/4678034b69a1447288d53841ea6c4435/ac99e/githubPagesSetting.webp 960w,
/static/4678034b69a1447288d53841ea6c4435/4df83/githubPagesSetting.webp 1440w,
/static/4678034b69a1447288d53841ea6c4435/fc987/githubPagesSetting.webp 1920w&quot;
              sizes=&quot;(max-width: 960px) 100vw, 960px&quot;
              type=&quot;image/webp&quot;
            /&gt;
          &lt;source
            srcset=&quot;/static/4678034b69a1447288d53841ea6c4435/85704/githubPagesSetting.webp 240w,
/static/4678034b69a1447288d53841ea6c4435/2d484/githubPagesSetting.webp 480w,
/static/4678034b69a1447288d53841ea6c4435/ac99e/githubPagesSetting.webp 960w,
/static/4678034b69a1447288d53841ea6c4435/4df83/githubPagesSetting.webp 1440w,
/static/4678034b69a1447288d53841ea6c4435/fc987/githubPagesSetting.webp 1920w&quot;
            sizes=&quot;(max-width: 960px) 100vw, 960px&quot;
            type=&quot;image/webp&quot;
          /&gt;
          &lt;img
            class=&quot;gatsby-resp-image-image&quot;
            src=&quot;/static/4678034b69a1447288d53841ea6c4435/ac99e/githubPagesSetting.webp&quot;
            alt=&quot;githubPagesSetting.png&quot;
            title=&quot;&quot;
            loading=&quot;lazy&quot;
            decoding=&quot;async&quot;
            style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
          /&gt;
        &lt;/picture&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;現在、Build and deployment には GitHub Actions の使用が推奨されていますので、/.github/workflows/ に下記のワークフローを置きます。
これは master ブランチに push されたら./public ディレクトリ(gatsby build で生成される静的ファイルのデフォルトの置き場)を GitHub Pages にデプロイするワークフローです。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;name: Deploy static content to Pages

on:
  push:
    branches: [&quot;master&quot;]
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: &quot;pages&quot;
  cancel-in-progress: false

jobs:
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Pages
        uses: actions/configure-pages@v5
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: &quot;./public&quot;
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;この記事では基本的な構成に焦点を当てて説明しましたが、以上の手順で AWS にデプロイされていた WordPress サイトを GatsbyJS と GitHub Pages を用いた静的サイトへと移行することができました。&lt;br&gt;
静的サイトに移行することで、サイトのパフォーマンス向上とセキュリティ強化を実現できます。ぜひ試してみてください。&lt;/p&gt;
&lt;hr&gt;
&lt;div class=&quot;booklink-box&quot; style=&quot;text-align:left;padding-bottom:20px;font-size:small;zoom: 1;overflow: hidden;&quot;&gt;&lt;div class=&quot;booklink-image&quot; style=&quot;float:left;margin:0 15px 10px 0;&quot;&gt;&lt;a href=&quot;&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;&lt;img src=&quot;https://thumbnail.image.rakuten.co.jp/@0_mall/book/cabinet/9546/9784844379546.jpg?_ex=200x200&quot; style=&quot;border: none;&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;booklink-info&quot; style=&quot;line-height:120%;zoom: 1;overflow: hidden;&quot;&gt;&lt;div class=&quot;booklink-name&quot; style=&quot;margin-bottom:10px;line-height:120%&quot;&gt;&lt;a href=&quot;&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;【POD】React &amp;amp; Gatsby開発入門&lt;/a&gt;&lt;div class=&quot;booklink-powered-date&quot; style=&quot;font-size:8pt;margin-top:5px;font-family:verdana;line-height:120%&quot;&gt;posted with &lt;a href=&quot;https://yomereba.com&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;ヨメレバ&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;booklink-detail&quot; style=&quot;margin-bottom:5px;&quot;&gt;竹本 雄貴 インプレスR&amp;amp;D 2021年04月02日頃    &lt;/div&gt;&lt;div class=&quot;booklink-link2&quot; style=&quot;margin-top:10px;&quot;&gt;&lt;div class=&quot;shoplinkamazon&quot; style=&quot;margin:5px 0&quot;&gt;&lt;a href=&quot;//af.moshimo.com/af/c/click?a_id=1041250&amp;amp;p_id=170&amp;amp;pc_id=185&amp;amp;pl_id=4062&amp;amp;s_v=b5Rz2P0601xu&amp;amp;url=https%3A%2F%2Fwww.amazon.co.jp%2Fexec%2Fobidos%2FASIN%2F4844379542&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;Amazon&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;shoplinkkindle&quot; style=&quot;margin:5px 0&quot;&gt;&lt;a href=&quot;//af.moshimo.com/af/c/click?a_id=1041250&amp;amp;p_id=170&amp;amp;pc_id=185&amp;amp;pl_id=4062&amp;amp;s_v=b5Rz2P0601xu&amp;amp;url=https%3A%2F%2Fwww.amazon.co.jp%2Fgp%2Fsearch%3Fkeywords%3D%25E3%2580%2590POD%25E3%2580%2591React%2520%2526%2520Gatsby%25E9%2596%258B%25E7%2599%25BA%25E5%2585%25A5%25E9%2596%2580%26__mk_ja_JP%3D%2583J%2583%255E%2583J%2583i%26url%3Dnode%253D2275256051&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;Kindle&lt;/a&gt;&lt;/div&gt;                               	   	   	  	  &lt;div class=&quot;shoplinktoshokan&quot; style=&quot;margin:5px 0&quot;&gt;&lt;a href=&quot;http://calil.jp/book/4844379542&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;図書館&lt;/a&gt;&lt;/div&gt;	&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;booklink-footer&quot; style=&quot;clear: left&quot;&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded></item></channel></rss>